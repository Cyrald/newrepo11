# COMPREHENSIVE SECURITY & CODE AUDIT REPORT
## E-Commerce Platform "ЭкоМаркет" - Полный аудит и рекомендации

**Дата аудита:** 27 ноября 2025  
**Версия проекта:** MVP Stage  
**Статус:** Нуждается в critical security fixes + architectural refactoring

---

## СОДЕРЖАНИЕ

1. [АНАЛИЗ БЕЗОПАСНОСТИ (Security Audit)](#анализ-безопасности)
2. [АРХИТЕКТУРНЫЕ УЛУЧШЕНИЯ (Architecture)](#архитектурные-улучшения)
3. [UI/UX АНАЛИЗ (User Experience)](#uiux-анализ)
4. [ФУНКЦИОНАЛЬНЫЕ УЛУЧШЕНИЯ (Features)](#функциональные-улучшения)
5. [ТЕСТИРОВАНИЕ (Testing Strategy)](#тестирование)
6. [DEPLOYMENT & INFRASTRUCTURE](#deployment--infrastructure)
7. [ПРИОРИТИЗАЦИЯ И ROADMAP](#приоритизация-и-roadmap)

---

## АНАЛИЗ БЕЗОПАСНОСТИ

### 1. CORS (Cross-Origin Resource Sharing)

**Текущее состояние:** ❌ НЕ НАСТРОЕН

**Риск:** CRITICAL  
**CVSS:** 7.5 (High)

**Проблема:**
```typescript
// server/index.ts - Сейчас так:
// Никаких CORS headers не установлены
app.use(express.json());

// Это позволяет любому сайту делать запросы к вашему API
// Уязвимо к:
// - Cookie stealing (CSRF attacks)
// - Unauthorized API calls
// - Data exfiltration
```

**Рекомендация:**
```typescript
// server/middleware/cors.ts (СОЗДАТЬ НОВЫЙ ФАЙЛ)
import cors from 'cors';

const allowedOrigins = process.env.NODE_ENV === 'production' 
  ? [process.env.FRONTEND_URL!]  // Только production domain
  : ['http://localhost:5000', 'http://localhost:3000'];

export const corsMiddleware = cors({
  origin: allowedOrigins,
  credentials: true,  // Allow cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400,  // Pre-flight cache 24 hours
  optionsSuccessStatus: 200
});

// server/index.ts
app.use(corsMiddleware);
```

**Дополнительные Security Headers:**
```typescript
// server/middleware/securityHeaders.ts
import helmet from 'helmet';

export const securityHeadersMiddleware = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],  // Remove inline scripts in prod
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: "cross-origin" },
  dnsPrefetchControl: { allow: false },
  frameguard: { action: 'deny' },
  hidePoweredBy: true,
  hsts: {
    maxAge: 31536000,  // 1 year
    includeSubDomains: true,
    preload: true,
  },
  ieNoOpen: true,
  noSniff: true,
  referrerPolicy: { policy: "strict-origin-when-cross-origin" },
  xssFilter: true,
});

app.use(securityHeadersMiddleware);
```

---

### 2. RATE LIMITING

**Текущее состояние:** ⚠️ СЛАБО НАСТРОЕН

**Риск:** HIGH  
**CVSS:** 7.0

**Проблемы:**
```typescript
// server/middleware/rateLimiter.ts - ТЕКУЩЕЕ:
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 min
  max: 100,  // 100 req per window
  message: "Слишком много попыток входа, попробуйте позже"
});

// ПРОБЛЕМЫ:
// 1. 100 req/min (6000 req/hour) - слишком много для auth
// 2. GET /api/products ВООБЩЕ НЕ ЛИМИТИРОВАН
// 3. File uploads не лимитированы
// 4. WebSocket не лимитирован
// 5. Нет sliding window strategy
// 6. Нет per-IP tracking в production
```

**Рекомендация - полная стратегия rate limiting:**

```typescript
// server/middleware/rateLimiter.ts (ПЕРЕПИСАТЬ)
import rateLimit, { Store } from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import redis from 'redis';

// В production используйте Redis для distributed rate limiting
// В development используйте in-memory store
const redisClient = redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
});

const createRedisStore = () => new RedisStore({
  client: redisClient,
  prefix: 'rl:',
  expiry: 60,  // Clear after 60 seconds
});

// AUTHENTICATION endpoints - строгий лимит
export const authLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 5,  // 5 attempts per 15 min (вместо 100!)
  skipSuccessfulRequests: true,  // Don't count successful logins
  message: 'Слишком много попыток входа. Попробуйте через 15 минут.',
  standardHeaders: true,
  legacyHeaders: false,
});

// REGISTRATION - еще строже
export const registerLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 60 * 60 * 1000,  // 1 hour
  max: 3,  // 3 registrations per hour per IP
  message: 'Слишком много регистраций. Попробуйте позже.',
  standardHeaders: true,
  legacyHeaders: false,
});

// API endpoints - умеренный лимит
export const apiLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 30,  // 30 requests per minute
  standardHeaders: true,
  legacyHeaders: false,
});

// FILE UPLOADS - очень строгий
export const uploadLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 60 * 60 * 1000,  // 1 hour
  max: 20,  // 20 uploads per hour
  message: 'Слишком много загрузок. Лимит: 20 в час.',
  standardHeaders: true,
  legacyHeaders: false,
});

// PROMOCODE VALIDATION - строгий (prevent brute force)
export const promocodeValidationLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 60 * 60 * 1000,  // 1 hour
  max: 10,  // 10 attempts per hour
  message: 'Слишком много попыток валидации промокода.',
  standardHeaders: true,
  legacyHeaders: false,
});

// SEARCH - умеренный
export const searchLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 50,  // 50 searches per minute
  standardHeaders: true,
  legacyHeaders: false,
});

// GENERAL API - default
export const generalApiLimiter = rateLimit({
  store: createRedisStore(),
  windowMs: 1 * 60 * 1000,  // 1 minute
  max: 100,  // 100 requests per minute
  standardHeaders: true,
  legacyHeaders: false,
});
```

**Применение в routes:**
```typescript
// server/routes.ts
// БЫЛО:
app.post("/api/auth/login", authLimiter, async (req, res) => { ... });

// ДОЛЖНО БЫТЬ:
app.post("/api/auth/login", authLimiter, async (req, res) => { ... });
app.post("/api/auth/register", registerLimiter, async (req, res) => { ... });
app.get("/api/products", generalApiLimiter, async (req, res) => { ... });  // NOW PROTECTED!
app.get("/api/products/:id", generalApiLimiter, async (req, res) => { ... });
app.post("/api/search", searchLimiter, async (req, res) => { ... });
app.post("/api/products", uploadLimiter, async (req, res) => { ... });
```

**Monitoring Rate Limits:**
```typescript
// server/utils/rateLimitMonitoring.ts
export async function monitorRateLimitViolations(redisClient: any) {
  setInterval(async () => {
    const keys = await redisClient.keys('rl:*');
    const violations = keys.filter(k => {
      const count = redisClient.get(k);
      return count > 20;  // Arbitrary threshold
    });
    
    if (violations.length > 0) {
      console.warn(`⚠️ Rate limit violations detected:`, violations);
      // Send alert to monitoring system (Sentry, DataDog, etc.)
    }
  }, 5 * 60 * 1000);  // Check every 5 minutes
}
```

---

### 3. INPUT SANITIZATION & VALIDATION

**Текущее состояние:** ⚠️ ЧАСТИЧНАЯ

**Риск:** HIGH  
**CVSS:** 7.2

**Проблемы:**
```typescript
// server/routes.ts - Product search
app.get("/api/products", async (req, res) => {
  try {
    let { search = "", categoryId = "", page = "1", limit = "12" } = req.query;
    
    // ❌ ПРОБЛЕМА: search не валидирован должным образом
    // Может содержать SQL injection patterns (хоть и ORM защищает)
    // Нет length limit (DoS)
    
    // ✅ Есть попытка (sanitizeSearchQuery в utils/sanitize.ts)
    // Но неполная
  }
});

// ❌ ANOTHER PROBLEM:
app.post("/api/addresses", authenticateToken, async (req, res) => {
  const addressSchema = z.object({
    label: z.string().min(1),  // ⚠️ Нет max length!
    fullAddress: z.string().min(1),  // ⚠️ Нет max length!
    city: z.string().min(1),
    street: z.string().min(1),
    building: z.string().min(1),
    apartment: z.string().optional(),
    postalCode: z.string().min(1),  // ⚠️ Нет regex validation
    isDefault: z.boolean().optional(),
  });
  // Можно передать 100 MB строку в fullAddress
});
```

**Рекомендация - Comprehensive Input Validation:**

```typescript
// server/utils/sanitize.ts (ПЕРЕПИСАТЬ И РАСШИРИТЬ)
import xss from 'xss';
import validator from 'validator';

const XSS_OPTIONS = {
  whiteList: {},  // No HTML allowed
  stripIgnoredTag: true,
  stripLeakage: true,
};

export function sanitizeSearchQuery(input: string): string {
  if (!input || typeof input !== 'string') return '';
  
  // Length check
  if (input.length > 100) {
    throw new Error('Поисковый запрос не должен превышать 100 символов');
  }
  
  // Remove XSS
  let sanitized = xss(input, XSS_OPTIONS);
  
  // Remove special SQL characters
  sanitized = sanitized
    .replace(/[;'"`]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  
  return sanitized;
}

export function sanitizeProductName(name: string): string {
  if (!name || typeof name !== 'string') return '';
  if (name.length > 200) {
    throw new Error('Название товара не должно превышать 200 символов');
  }
  return xss(name, XSS_OPTIONS).trim();
}

export function sanitizeDescription(desc: string): string {
  if (!desc || typeof desc !== 'string') return '';
  if (desc.length > 5000) {
    throw new Error('Описание не должно превышать 5000 символов');
  }
  return xss(desc, XSS_OPTIONS).trim();
}

export function sanitizeEmail(email: string): string {
  if (!validator.isEmail(email)) {
    throw new Error('Неверный формат email');
  }
  return email.toLowerCase().trim();
}

export function sanitizePhoneNumber(phone: string): string {
  // Russian phone format: +7 (XXX) XXX-XX-XX
  const cleaned = phone.replace(/\D/g, '');
  
  if (!validator.isMobilePhone(cleaned, 'ru-RU')) {
    throw new Error('Неверный формат номера телефона');
  }
  
  return '+' + cleaned;
}

export function sanitizePostalCode(code: string): string {
  const russian_postal_regex = /^\d{6}$/;
  if (!russian_postal_regex.test(code)) {
    throw new Error('Почтовый индекс должен состоять из 6 цифр');
  }
  return code;
}

export function sanitizeAddress(address: string): string {
  if (!address || typeof address !== 'string') return '';
  if (address.length > 500) {
    throw new Error('Адрес не должен превышать 500 символов');
  }
  return xss(address, XSS_OPTIONS).trim();
}

export function sanitizeNumericParam(value: any, min = 0, max = 10000): number {
  const num = parseInt(value, 10);
  
  if (isNaN(num)) {
    throw new Error('Параметр должен быть числом');
  }
  
  if (num < min || num > max) {
    throw new Error(`Значение должно быть между ${min} и ${max}`);
  }
  
  return num;
}

export function sanitizeId(id: string): string {
  // UUID format validation
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  
  if (!uuidRegex.test(id)) {
    throw new Error('Неверный формат ID');
  }
  
  return id;
}

export function sanitizeUrl(url: string): string {
  try {
    const parsed = new URL(url);
    
    // Only allow http/https
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      throw new Error('Только HTTP/HTTPS протоколы разрешены');
    }
    
    return parsed.toString();
  } catch (e) {
    throw new Error('Неверный URL');
  }
}

export function validatePasswordStrength(password: string): boolean {
  // Минимум 8 символов
  // Минимум 1 заглавная буква
  // Минимум 1 строчная буква
  // Минимум 1 цифра
  // Минимум 1 специальный символ
  
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  
  return strongPasswordRegex.test(password);
}
```

**Обновленные schemas:**
```typescript
// shared/schema.ts (UPDATE)
import { z } from 'zod';

export const addressSchema = z.object({
  label: z.string().min(1).max(50, 'Максимум 50 символов'),
  fullAddress: z.string().min(10).max(500, 'Максимум 500 символов'),
  city: z.string().min(2).max(100),
  street: z.string().min(2).max(100),
  building: z.string().min(1).max(10),
  apartment: z.string().max(10).optional(),
  postalCode: z.string().regex(/^\d{6}$/, 'Индекс: 6 цифр'),
  isDefault: z.boolean().optional(),
});

export const productSchema = z.object({
  name: z.string().min(5).max(200),
  description: z.string().min(10).max(5000),
  price: z.string().refine(val => !isNaN(parseFloat(val)) && parseFloat(val) > 0),
  sku: z.string().min(1).max(50).optional(),
  categoryId: z.string().uuid(),
  // ... другие поля
});

export const emailSchema = z.string().email('Неверный email').max(255);

export const phoneSchema = z.string()
  .regex(/^[\d\s\+\-\(\)]{10,20}$/, 'Неверный номер телефона');
```

---

### 4. SESSION SECURITY

**Текущее состояние:** ⚠️ НЕПОЛНАЯ

**Риск:** HIGH  
**CVSS:** 7.1

**Проблемы:**
```typescript
// server/index.ts
const sessionStore = new (require('connect-pg-simple')(session))({
  pool: pool,
});

app.use(
  session({
    store: sessionStore,
    secret: env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: env.NODE_ENV === 'production',  // ⚠️ Unsafe in development!
      httpOnly: true,  // ✅ Good
      sameSite: 'lax',  // ⚠️ Should be 'strict' for auth
      maxAge: 24 * 60 * 60 * 1000,  // ⚠️ 24 hours
    },
  })
);

// ПРОБЛЕМЫ:
// 1. Secure флаг только в production (должен быть везде)
// 2. SameSite 'lax' (CSRF vulnerability - should be 'strict')
// 3. Нет session rotation на login (session fixation атака)
// 4. Нет session invalidation на logout - БАГ!
```

**Рекомендация (Баланс: Безопасность + UX):**

```typescript
// server/index.ts (UPDATE)
app.use(
  session({
    store: sessionStore,
    secret: env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    name: 'sessionId',  // Don't use default 'connect.sid'
    cookie: {
      secure: true,  // ✅ ALWAYS secure - localhost автоматически исключен
      httpOnly: true,  // ✅ Защита от XSS
      sameSite: 'strict',  // ✅ Защита от CSRF - cookie только с того же домена
      maxAge: 7 * 24 * 60 * 60 * 1000,  // ✅ 7 дней (или не устанавливать для unlimited)
      path: '/',
    },
  })
);

// ✅ УДАЛИЛИ:
// - Activity timeout (удобство > security)
// - Принудительные разлогины
// + Оставили простоту для пользователя

// server/routes.ts - LOGIN endpoint
app.post("/api/auth/login", authLimiter, async (req, res) => {
  try {
    const data = loginSchema.parse(req.body);
    const user = await storage.getUserByEmail(data.email);
    
    if (!user) {
      return res.status(401).json({ message: "Неверный email или пароль" });
    }

    const isValidPassword = await comparePassword(data.password, user.passwordHash);
    if (!isValidPassword) {
      return res.status(401).json({ message: "Неверный email или пароль" });
    }

    const roles = await storage.getUserRoles(user.id);
    const roleNames = roles.map(r => r.role);
    
    // ✅ ДОБАВИТЬ: Session rotation - защита от session fixation
    req.session.regenerate((err) => {
      if (err) {
        return res.status(500).json({ message: "Ошибка входа" });
      }
      
      req.session.userId = user.id;
      req.session.userRoles = roleNames;
      req.session.loginTime = Date.now();
      
      res.json({
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          roles: roleNames,
        },
      });
    });
  } catch (error) {
    res.status(500).json({ message: "Ошибка входа" });
  }
});

// server/routes.ts - LOGOUT endpoint (СУЩЕСТВУЕТ)
app.post("/api/auth/logout", authenticateToken, async (req, res) => {
  try {
    // ✅ Invalidate session in database
    await db.delete(sessions).where(eq(sessions.userId, req.userId!));
    
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Ошибка выхода" });
      }
      
      res.clearCookie('sessionId', {
        secure: true,
        httpOnly: true,
        sameSite: 'strict',
        path: '/',
      });
      
      res.json({ message: "Выход выполнен успешно" });
    });
  } catch (error) {
    res.status(500).json({ message: "Ошибка выхода" });
  }
});
```

**Решённые проблемы:**
| Проблема | Решение | Зачем |
|----------|---------|-------|
| `secure` только в prod | secure=true везде | Защита от MITM (localhost исключен автоматически) |
| `sameSite: 'lax'` | `sameSite: 'strict'` | Защита от CSRF - cookie ≠ отправляется с других сайтов |
| Нет rotation | `regenerate()` на login | Защита от session fixation атак |
| maxAge 24h | maxAge 7 дней+ | UX - пользователь в системе долго, комфортно |
| ❌ Activity timeout | ✅ УДАЛИЛИ | UX - нет принудительных разлогинов |

---

### 5. FILE UPLOAD SECURITY

**Текущее состояние:** ⚠️ БАЗОВАЯ ЗАЩИТА

**Риск:** HIGH  
**CVSS:** 7.3

**Проблемы:**
```typescript
// server/upload.ts
const productImagesUpload = multer({
  storage: storage,
  limits: {
    fileSize: 50 * 1024 * 1024,  // ⚠️ 50MB - слишком много!
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["image/jpeg", "image/png", "image/webp"];
    
    // ⚠️ MIME type can be spoofed!
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Недопустимый тип файла"));
    }
  },
});

// ПРОБЛЕМЫ:
// 1. MIME type check - легко подделать
// 2. Нет проверки расширения файла
// 3. Нет проверки магических чисел (file signature)
// 4. Нет file rename (защита от traversal)
// 5. Нет rate limiting на file uploads
// 6. Stored в upload directory без versioning

// ПРИМЕЧАНИЕ: 50MB для админ панели ОСТАВЛЯЕМ (доверяем модераторам)
// Для чата поддержки позже будет отдельный лимит (меньше)
```

**Рекомендация (Баланс: Безопасность + Удобство):**

```typescript
// server/upload.ts (ПЕРЕПИСАТЬ)
import multer from 'multer';
import path from 'path';
import crypto from 'crypto';
import sharp from 'sharp';
import { FileType } from 'file-type';

const UPLOAD_DIR = path.join(process.cwd(), 'uploads');
const ALLOWED_MIMES = new Set(['image/jpeg', 'image/png', 'image/webp']);
const ALLOWED_EXTENSIONS = new Set(['.jpg', '.jpeg', '.png', '.webp']);
const MAX_FILE_SIZE_ADMIN = 50 * 1024 * 1024;    // 50MB для админ панели (доверяем модераторам)
const MAX_FILE_SIZE_CHAT = 5 * 1024 * 1024;      // 5MB для чата поддержки (потом)
const MAX_FILES_PER_REQUEST = 10;

// Storage configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOAD_DIR);
  },
  filename: (req, file, cb) => {
    // Use crypto-random name to prevent traversal
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname).toLowerCase();
    cb(null, `${crypto.randomUUID()}-${uniqueSuffix}${ext}`);
  },
});

// Comprehensive file filter
const fileFilter = async (req: any, file: any, cb: any) => {
  try {
    // 1. Check MIME type
    if (!ALLOWED_MIMES.has(file.mimetype)) {
      return cb(new Error(`Недопустимый тип файла: ${file.mimetype}`));
    }

    // 2. Check extension
    const ext = path.extname(file.originalname).toLowerCase();
    if (!ALLOWED_EXTENSIONS.has(ext)) {
      return cb(new Error(`Недопустимое расширение: ${ext}`));
    }

    // 3. Check file signature (magic numbers)
    const buffer = await sharp(file.path).metadata();
    
    const allowedFormats = ['jpeg', 'png', 'webp'];
    if (!allowedFormats.includes(buffer.format as string)) {
      return cb(new Error('Файл не является допустимым изображением'));
    }

    // 4. Check dimensions (prevent huge images)
    if ((buffer.width || 0) > 10000 || (buffer.height || 0) > 10000) {
      return cb(new Error('Размеры изображения слишком большие'));
    }

    cb(null, true);
  } catch (error: any) {
    cb(new Error(`Ошибка валидации файла: ${error.message}`));
  }
};

// АДМИН ПАНЕЛЬ: 50MB (доверяем модераторам создавать товары)
export const productImagesUpload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_ADMIN,  // 50MB для админ панели
    files: MAX_FILES_PER_REQUEST,
  },
});

// ЧАТ ПОДДЕРЖКИ: 5MB (будет добавлено позже для пользователей)
export const chatAttachmentsUpload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_CHAT,  // 5MB for chat attachments
    files: 3,
  },
});

// server/middleware/fileUploadValidator.ts (CREATE)
export async function validateUploadedFile(filepath: string): Promise<boolean> {
  try {
    const metadata = await sharp(filepath).metadata();
    
    // Re-validate format
    if (!['jpeg', 'png', 'webp'].includes(metadata.format as string)) {
      throw new Error('Invalid image format');
    }
    
    // Validate dimensions again
    if ((metadata.width || 0) > 10000 || (metadata.height || 0) > 10000) {
      throw new Error('Image dimensions exceed limits');
    }
    
    return true;
  } catch (error) {
    // Delete invalid file
    await fs.promises.unlink(filepath).catch(() => {});
    throw error;
  }
}

// Cleanup old files periodically
export function startFileCleanupTask() {
  setInterval(async () => {
    try {
      const files = await fs.promises.readdir(UPLOAD_DIR);
      const now = Date.now();
      
      for (const file of files) {
        const filepath = path.join(UPLOAD_DIR, file);
        const stats = await fs.promises.stat(filepath);
        
        // Delete files older than 30 days
        if (now - stats.mtimeMs > 30 * 24 * 60 * 60 * 1000) {
          await fs.promises.unlink(filepath);
        }
      }
    } catch (error) {
      console.error('File cleanup error:', error);
    }
  }, 24 * 60 * 60 * 1000);  // Run daily
}
```

---

### 6. ERROR HANDLING & LOGGING

**Текущое состояние:** ⚠️ НЕ СТРУКТУРИРОВАННО

**Риск:** MEDIUM  
**CVSS:** 5.5

**Проблемы:**
```typescript
// server/routes.ts - Во многих endpoints:
app.post("/api/auth/login", authLimiter, async (req, res) => {
  try {
    // ... code ...
  } catch (error) {
    // ⚠️ Generic catch - выдает слишком много информации
    res.status(500).json({ message: "Ошибка входа" });
  }
});

// ПРОБЛЕМЫ:
// 1. Нет structured logging (JSON logs для production)
// 2. Нет request IDs для tracking
// 3. Нет centralized error handler
// 4. Error messages не консистентны
// 5. Нет distinction между client и server errors
// 6. Нет logging security events
// 7. Stack traces выдаются в production
```

**Рекомендация:**

```typescript
// server/utils/logger.ts (CREATE)
import winston from 'winston';
import { v4 as uuidv4 } from 'uuid';

const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

winston.addColors(colors);

const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.printf(
    (info) => `${info.timestamp} ${info.level}: ${info.message}`,
  ),
);

const transports = [
  new winston.transports.Console(),
  new winston.transports.File({
    filename: 'logs/error.log',
    level: 'error',
    format: winston.format.json(),
  }),
  new winston.transports.File({
    filename: 'logs/all.log',
    format: winston.format.json(),
  }),
];

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'debug',
  levels,
  format,
  transports,
});

// server/middleware/requestLogger.ts (CREATE)
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';

declare global {
  namespace Express {
    interface Request {
      id: string;
    }
  }
}

export function requestLogger(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  req.id = uuidv4();
  
  const startTime = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    
    logger.http(
      `[${req.id}] ${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`,
    );
    
    // Log sensitive operations
    if (req.method !== 'GET') {
      logger.info(
        `[${req.id}] ${req.method} ${req.path} by user ${req.userId || 'anonymous'}`,
      );
    }
  });
  
  next();
}

// server/middleware/errorHandler.ts (CREATE)
import { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { ZodError } from 'zod';

export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public isOperational = true,
  ) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

export function errorHandler(
  error: any,
  req: Request,
  res: Response,
  next: NextFunction,
): void {
  const requestId = req.id || 'unknown';
  
  logger.error(`[${requestId}] Error: ${error.message}`, {
    stack: error.stack,
    path: req.path,
    method: req.method,
    userId: req.userId,
  });

  // Zod validation errors
  if (error instanceof ZodError) {
    res.status(400).json({
      success: false,
      message: 'Validation error',
      errors: error.errors.map(e => ({
        path: e.path.join('.'),
        message: e.message,
      })),
      requestId,
    });
    return;
  }

  // Application errors
  if (error instanceof AppError) {
    res.status(error.statusCode).json({
      success: false,
      message: error.message,
      requestId,
    });
    return;
  }

  // File upload errors
  if (error.code === 'LIMIT_FILE_SIZE') {
    res.status(413).json({
      success: false,
      message: 'Файл слишком большой. Максимум 5MB.',
      requestId,
    });
    return;
  }

  if (error.code === 'LIMIT_FILE_COUNT') {
    res.status(413).json({
      success: false,
      message: 'Слишком много файлов. Максимум 10.',
      requestId,
    });
    return;
  }

  // Default error
  res.status(error.statusCode || 500).json({
    success: false,
    message: process.env.NODE_ENV === 'production' 
      ? 'Внутренняя ошибка сервера'
      : error.message,
    requestId,
  });
}

// server/index.ts
app.use(requestLogger);
app.use(errorHandler);
```

**Update routes to use AppError:**
```typescript
// server/routes.ts
app.post("/api/auth/login", authLimiter, async (req, res, next) => {
  try {
    const data = loginSchema.parse(req.body);
    const user = await storage.getUserByEmail(data.email);
    
    if (!user) {
      throw new AppError(401, "Неверный email или пароль");
    }

    const isValidPassword = await comparePassword(data.password, user.passwordHash);
    if (!isValidPassword) {
      throw new AppError(401, "Неверный email или пароль");
    }
    
    // ... rest of logic
  } catch (error) {
    next(error);  // Pass to error handler
  }
});
```

---

### 7. AUTHENTICATION & AUTHORIZATION

**Текущее состояние:** ✅ ХОРОШО (но есть улучшения)

**Риск:** MEDIUM

**Потенциальные улучшения:**

```typescript
// server/middleware/authAdvanced.ts (CREATE)
import jwt from 'jsonwebtoken';

// Add refresh token support
export async function generateRefreshToken(userId: string): Promise<string> {
  const token = jwt.sign(
    { userId, type: 'refresh' },
    process.env.REFRESH_TOKEN_SECRET!,
    { expiresIn: '7d' }
  );
  
  // Store in database for revocation
  await db.insert(refreshTokens).values({
    userId,
    token,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  });
  
  return token;
}

// Audit logging for authorization checks
export async function auditLog(
  userId: string,
  action: string,
  resource: string,
  success: boolean,
  details?: Record<string, any>
): Promise<void> {
  await db.insert(auditLogs).values({
    userId,
    action,
    resource,
    success,
    details: JSON.stringify(details),
    createdAt: new Date(),
    ipAddress: details?.ipAddress,
    userAgent: details?.userAgent,
  });
}

// Enhanced role checking with audit
export function requireRoleWithAudit(...roles: string[]) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    if (!req.userId) {
      await auditLog('unknown', 'access_denied', req.path, false, {
        ipAddress: req.ip,
        reason: 'not_authenticated',
      });
      res.status(401).json({ message: "Требуется аутентификация" });
      return;
    }

    if (!req.userRoles) {
      await auditLog(req.userId, 'access_denied', req.path, false, {
        ipAddress: req.ip,
        reason: 'roles_not_loaded',
      });
      res.status(403).json({ message: "Роли пользователя не загружены" });
      return;
    }

    const hasRole = req.userRoles.some(role => roles.includes(role));
    if (!hasRole) {
      await auditLog(req.userId, 'access_denied', req.path, false, {
        ipAddress: req.ip,
        requiredRoles: roles,
        userRoles: req.userRoles,
      });
      res.status(403).json({ message: "Недостаточно прав" });
      return;
    }

    // Log successful access
    await auditLog(req.userId, 'access_granted', req.path, true);

    next();
  };
}
```

---

### 8. WebSocket Security

**Текущое состояние:** ⚠️ БАЗОВАЯ

**Риск:** MEDIUM

**Рекомендация:**

```typescript
// server/routes.ts - WebSocket section (УЛУЧШИТЬ)
wss.on("connection", async (ws: any, req: any) => {
  let userId: string | null = null;
  let authenticated = false;
  const connectionId = uuidv4();  // Track connection

  // Connection timeout
  const connectionTimeout = setTimeout(() => {
    if (!authenticated) {
      ws.close(4001, 'Authentication timeout');
    }
  }, 5000);

  ws.on("message", async (data: any) => {
    try {
      const message = JSON.parse(data.toString());

      if (message.type === "auth") {
        clearTimeout(connectionTimeout);
        
        // Validate session more strictly
        const sessionData = await validateSessionFromCookie(req.headers.cookie);

        if (!sessionData) {
          ws.send(JSON.stringify({
            type: "auth_error",
            message: "Сессия недействительна",
            requestId: connectionId,
          }));
          ws.close(4001, 'Invalid session');
          return;
        }

        userId = sessionData.userId;
        authenticated = true;

        // Check for concurrent connections limit
        const existingConnections = Array.from(connectedUsers.entries())
          .filter(([id]) => id === userId).length;
        
        if (existingConnections > 5) {  // Max 5 concurrent connections
          ws.close(4002, 'Too many connections');
          return;
        }

        // Log connection
        logger.info(`WebSocket connected: ${userId} (${connectionId})`);

        connectedUsers.set(`${userId}:${connectionId}`, { 
          ws, 
          roles: sessionData.userRoles,
          connectedAt: Date.now(),
        });

        ws.send(JSON.stringify({
          type: "auth_success",
          message: "Подключение установлено",
          requestId: connectionId,
        }));
        return;
      }

      if (!authenticated) {
        ws.send(JSON.stringify({
          type: "error",
          message: "Необходима аутентификация",
        }));
        return;
      }

      // Rate limit WebSocket messages
      if (!ws.messageCount) ws.messageCount = 0;
      if (!ws.lastMessageTime) ws.lastMessageTime = Date.now();

      const timeDiff = Date.now() - ws.lastMessageTime;
      if (timeDiff < 1000) {
        ws.messageCount++;
        if (ws.messageCount > 10) {
          ws.close(4003, 'Rate limit exceeded');
          return;
        }
      } else {
        ws.messageCount = 0;
      }
      ws.lastMessageTime = Date.now();

      // Handle different message types
      // ...
    } catch (error) {
      logger.error(`WebSocket error: ${error}`);
      ws.send(JSON.stringify({
        type: "error",
        message: "Ошибка обработки сообщения",
      }));
    }
  });

  ws.on("close", () => {
    if (userId) {
      connectedUsers.delete(`${userId}:${connectionId}`);
      logger.info(`WebSocket disconnected: ${userId} (${connectionId})`);
    }
    clearTimeout(connectionTimeout);
  });

  ws.on("error", (error: any) => {
    logger.error(`WebSocket error: ${error.message}`);
  });
});
```

---

### 9. DATA VALIDATION - Database Level

**Текущое состояние:** ⚠️ PARTIAL

**Риск:** MEDIUM

**Рекомендация:**

```typescript
// shared/schema.ts - Добавить более строгие constraints
import { sql } from 'drizzle-orm';

export const users = pgTable('users', {
  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
  email: varchar('email').unique().notNull(),
  passwordHash: varchar('password_hash').notNull(),
  firstName: varchar('first_name').notNull(),
  lastName: varchar('last_name'),
  patronymic: varchar('patronymic'),
  phone: varchar('phone'),
  bonusBalance: integer('bonus_balance').default(0).notNull(),
  isVerified: boolean('is_verified').default(false),
  verificationToken: varchar('verification_token'),
  verificationTokenExpires: timestamp('verification_token_expires'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
},
(table) => ({
  emailIdx: index('email_idx').on(table.email),
  phoneIdx: index('phone_idx').on(table.phone),
  // Constraints
  emailCheck: sql`CHECK (email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')`,
  phoneCheck: sql`CHECK (phone ~ '^\\+?[0-9\\s\\-\\(\\)]{10,}$' OR phone IS NULL)`,
  firstNameCheck: sql`CHECK (LENGTH(first_name) >= 2 AND LENGTH(first_name) <= 100)`,
  bonusCheck: sql`CHECK (bonus_balance >= 0)`,
}));
```

---

## АРХИТЕКТУРНЫЕ УЛУЧШЕНИЯ

### 1. Backend Modularization

**Текущое состояние:** ⚠️ МОНОЛИТНО

**Проблема:**
```typescript
// server/storage.ts - 1000+ lines!
// Все операции с БД в одном файле:
// - User management
// - Product management
// - Order management
// - Cart management
// - Wishlist management
// - Support chat
// - Addresses
// - Payment cards
// - Все вместе -> UNMAINTAINABLE
```

**Рекомендация - Domain-Driven Architecture:**

```
server/
├── domains/
│   ├── users/
│   │   ├── users.service.ts
│   │   ├── users.repository.ts
│   │   ├── users.routes.ts
│   │   └── users.schema.ts
│   ├── products/
│   │   ├── products.service.ts
│   │   ├── products.repository.ts
│   │   ├── products.routes.ts
│   │   └── products.schema.ts
│   ├── orders/
│   │   ├── orders.service.ts
│   │   ├── orders.repository.ts
│   │   ├── orders.routes.ts
│   │   └── orders.schema.ts
│   ├── cart/
│   ├── wishlist/
│   ├── support/
│   ├── addresses/
│   └── payments/
├── middleware/
│   ├── auth.ts
│   ├── rateLimiter.ts
│   ├── errorHandler.ts
│   ├── requestLogger.ts
│   └── cors.ts
├── utils/
│   ├── logger.ts
│   ├── sanitize.ts
│   ├── validators.ts
│   └── helpers.ts
└── index.ts
```

**Example domain structure:**

```typescript
// server/domains/users/users.repository.ts
import { db } from '../../db';
import { users, userRoles } from '@shared/schema';

export class UsersRepository {
  async findByEmail(email: string) {
    return db.query.users.findFirst({
      where: eq(users.email, email),
    });
  }

  async findById(id: string) {
    return db.query.users.findFirst({
      where: eq(users.id, id),
      with: {
        roles: true,
      },
    });
  }

  async create(data: CreateUserDTO) {
    return db.insert(users).values(data).returning();
  }

  async update(id: string, data: UpdateUserDTO) {
    return db.update(users)
      .set(data)
      .where(eq(users.id, id))
      .returning();
  }

  async delete(id: string) {
    return db.delete(users).where(eq(users.id, id));
  }
}

// server/domains/users/users.service.ts
import { UsersRepository } from './users.repository';
import { hashPassword, comparePassword } from '../../auth';

export class UsersService {
  private repository = new UsersRepository();

  async registerUser(email: string, password: string, firstName: string) {
    const existing = await this.repository.findByEmail(email);
    if (existing) {
      throw new AppError(400, "Email уже зарегистрирован");
    }

    const passwordHash = await hashPassword(password);
    const user = await this.repository.create({
      email,
      passwordHash,
      firstName,
    });

    return user;
  }

  async loginUser(email: string, password: string) {
    const user = await this.repository.findByEmail(email);
    if (!user) {
      throw new AppError(401, "Неверный email или пароль");
    }

    const isValid = await comparePassword(password, user.passwordHash);
    if (!isValid) {
      throw new AppError(401, "Неверный email или пароль");
    }

    return user;
  }
}

// server/domains/users/users.routes.ts
import { Router } from 'express';
import { UsersService } from './users.service';
import { authenticateToken } from '../../auth';

const router = Router();
const service = new UsersService();

router.post('/register', async (req, res, next) => {
  try {
    const user = await service.registerUser(
      req.body.email,
      req.body.password,
      req.body.firstName
    );
    res.json({ user });
  } catch (error) {
    next(error);
  }
});

router.post('/login', async (req, res, next) => {
  try {
    const user = await service.loginUser(req.body.email, req.body.password);
    res.json({ user });
  } catch (error) {
    next(error);
  }
});

export default router;
```

---

### 2. Frontend Component Refactoring

**Текущое состояние:** ⚠️ BIG COMPONENTS

**Проблема:**
```typescript
// client/src/pages/admin/products-page.tsx - 439 lines!
// ТЫ можно разбить на:
// - ProductsTable
// - ProductForm
// - ProductActions
// - ProductFilters
// - ProductSearch
```

**Рекомендация:**

```
client/src/pages/admin/
├── products-page.tsx (main page, ~100 lines)
├── products/
│   ├── ProductsTable.tsx
│   ├── ProductForm.tsx
│   ├── ProductFilters.tsx
│   ├── ProductSearch.tsx
│   ├── ProductActions.tsx
│   └── ProductImageUpload.tsx
└── ...
```

**Example refactoring:**

```typescript
// client/src/pages/admin/products/ProductsTable.tsx
import { Table, TableBody, TableCell } from '@/components/ui/table';
import { ProductActions } from './ProductActions';
import type { Product } from '@shared/schema';

interface ProductsTableProps {
  products: Product[];
  onEdit: (product: Product) => void;
  onArchive: (productId: string) => void;
  onDelete: (productId: string) => void;
  isLoading?: boolean;
}

export function ProductsTable({
  products,
  onEdit,
  onArchive,
  onDelete,
}: ProductsTableProps) {
  if (isLoading) return <LoadingSkeleton />;
  if (products.length === 0) return <EmptyState />;

  return (
    <Table>
      <TableBody>
        {products.map((product) => (
          <TableRow key={product.id}>
            <TableCell>
              <LazyProductImage product={product} />
            </TableCell>
            <TableCell>{product.name}</TableCell>
            <TableCell>{product.price}</TableCell>
            <TableCell>
              <ProductActions
                product={product}
                onEdit={onEdit}
                onArchive={onArchive}
                onDelete={onDelete}
              />
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

// client/src/pages/admin/products/ProductFilters.tsx
export function ProductFilters({
  searchQuery,
  onSearchChange,
  activeTab,
  onTabChange,
  sortOrder,
  onSortChange,
}: ProductFiltersProps) {
  return (
    <div className="space-y-4">
      <ProductSearch value={searchQuery} onChange={onSearchChange} />
      <Tabs value={activeTab} onValueChange={onTabChange}>
        <TabsList>
          <TabsTrigger value="published">Опубликованные</TabsTrigger>
          <TabsTrigger value="archived">Архив</TabsTrigger>
        </TabsList>
      </Tabs>
      <SortControls value={sortOrder} onChange={onSortChange} />
    </div>
  );
}

// client/src/pages/admin/products-page.tsx (REFACTORED - 100 lines)
export default function AdminProductsPage() {
  const [searchQuery, setSearchQuery] = useState("");
  const [activeTab, setActiveTab] = useState<"published" | "archived">("published");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("asc");

  const { data, isLoading } = useQuery({
    queryKey: ["adminProducts"],
    queryFn: () => productsApi.getAll({ limit: 10000, includeArchived: true }),
  });

  const products = data?.products || [];

  return (
    <AdminLayout>
      <div className="space-y-6">
        <PageHeader title="Товары" onAdd={handleAddProduct} />
        
        <ProductFilters
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          activeTab={activeTab}
          onTabChange={setActiveTab}
          sortOrder={sortOrder}
          onSortChange={setSortOrder}
        />

        <ProductsTable
          products={filterAndSortProducts(products, activeTab, searchQuery, sortOrder)}
          onEdit={handleEditProduct}
          onArchive={handleArchiveProduct}
          onDelete={handleDeleteProduct}
          isLoading={isLoading}
        />

        <ProductFormDialog isOpen={isFormOpen} onOpenChange={setIsFormOpen} />
      </div>
    </AdminLayout>
  );
}
```

---

### 3. Unified Error Handling

**Текущое состояние:** ⚠️ INCONSISTENT

**Рекомендация:**

```typescript
// server/utils/errors.ts (CREATE)
export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public code?: string,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, any>) {
    super(400, message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Требуется аутентификация') {
    super(401, message, 'AUTHENTICATION_ERROR');
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Недостаточно прав') {
    super(403, message, 'AUTHORIZATION_ERROR');
    this.name = 'AuthorizationError';
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(404, `${resource} не найден`, 'NOT_FOUND');
    this.name = 'NotFoundError';
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(409, message, 'CONFLICT');
    this.name = 'ConflictError';
  }
}

// server/middleware/errorHandler.ts (УЛУЧШИТЬ)
export function errorHandler(
  error: any,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const requestId = req.id || 'unknown';

  logger.error(`[${requestId}] ${error.name}: ${error.message}`, {
    statusCode: error.statusCode,
    code: error.code,
    stack: error.stack,
    details: error.details,
  });

  // Application errors
  if (error instanceof AppError) {
    res.status(error.statusCode).json({
      success: false,
      error: {
        message: error.message,
        code: error.code,
        details: process.env.NODE_ENV === 'development' ? error.details : undefined,
      },
      requestId,
    });
    return;
  }

  // Database errors
  if (error.code === 'P0001') {
    res.status(409).json({
      success: false,
      error: {
        message: 'Операция конфликтует с существующими данными',
        code: 'DB_CONFLICT',
      },
      requestId,
    });
    return;
  }

  // Unexpected error
  res.status(500).json({
    success: false,
    error: {
      message: process.env.NODE_ENV === 'production'
        ? 'Внутренняя ошибка сервера'
        : error.message,
      code: 'INTERNAL_SERVER_ERROR',
    },
    requestId,
  });
}
```

---

### 4. Database Connection Pooling & Optimization

**Текущое состояние:** ⚠️ БАЗОВОЕ

**Рекомендация:**

```typescript
// server/db.ts (УЛУЧШИТЬ)
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const queryClient = postgres(process.env.DATABASE_URL!, {
  max: 20,  // Connection pool size
  idle_timeout: 30,  // Close idle connections after 30s
  connect_timeout: 10,  // 10 second timeout
  backoff: (retries) => Math.exp(Math.min(retries, 6)) * 100,  // Exponential backoff
  onnotice: () => {},  // Suppress notices
});

// Monitor connection pool
if (process.env.NODE_ENV === 'development') {
  setInterval(() => {
    console.log(`Connection pool: ${queryClient.active}/${queryClient.idle}`);
  }, 60000);
}

export const db = drizzle(queryClient);

// Graceful shutdown
process.on('SIGTERM', async () => {
  await queryClient.end({ timeout: 30 });
  process.exit(0);
});
```

---

## UI/UX АНАЛИЗ

### 1. Mobile Responsiveness

**Текущое состояние:** ⚠️ НУЖДАЕТСЯ В УЛУЧШЕНИЯХ

**Проблемы на мобильных:**
- Admin panel слишком сложная
- Checkout process занимает множество экранов
- Touch targets маленькие
- Горизонтальный скролл на tables
- Modals не оптимизированы

**Рекомендация:**

```typescript
// client/src/components/admin-layout.tsx (УЛУЧШИТЬ)
export function AdminLayout({ children }: { children: React.ReactNode }) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const isMobile = useMediaQuery('(max-width: 768px)');

  return (
    <div className="flex h-screen">
      {/* Mobile: Drawer, Desktop: Sidebar */}
      {isMobile ? (
        <Sheet open={sidebarOpen} onOpenChange={setSidebarOpen}>
          <SheetContent side="left">
            <AdminSidebar onNavigate={() => setSidebarOpen(false)} />
          </SheetContent>
        </Sheet>
      ) : (
        <Sidebar />
      )}

      <main className="flex-1 overflow-auto">
        {isMobile && (
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setSidebarOpen(true)}
            className="m-4"
          >
            <Menu />
          </Button>
        )}
        {children}
      </main>
    </div>
  );
}

// client/src/components/responsive-table.tsx (CREATE)
// For mobile: list view instead of table
interface ResponsiveTableProps {
  data: any[];
  columns: ColumnDef<any>[];
  renderMobileRow: (item: any) => React.ReactNode;
}

export function ResponsiveTable({
  data,
  columns,
  renderMobileRow,
}: ResponsiveTableProps) {
  const isMobile = useMediaQuery('(max-width: 768px)');

  return (
    <>
      {isMobile ? (
        <div className="space-y-4">
          {data.map((item) => renderMobileRow(item))}
        </div>
      ) : (
        <Table>
          {/* Desktop table */}
        </Table>
      )}
    </>
  );
}
```

---

### 2. Accessibility (a11y)

**Текущое состояние:** ⚠️ НУЖДАЕТСЯ В РАБОТЕ

**Рекомендация:**

```typescript
// client/src/components/accessible-button.tsx
import { forwardRef } from 'react';
import { Button } from './ui/button';

interface AccessibleButtonProps extends React.ComponentProps<typeof Button> {
  ariaLabel?: string;
  ariaDescribedBy?: string;
  ariaPressed?: boolean;
  ariaExpanded?: boolean;
}

export const AccessibleButton = forwardRef<
  HTMLButtonElement,
  AccessibleButtonProps
>(({ ariaLabel, ariaDescribedBy, ...props }, ref) => (
  <Button
    ref={ref}
    aria-label={ariaLabel}
    aria-describedby={ariaDescribedBy}
    {...props}
  />
));

// client/src/components/form-input.tsx (УЛУЧШИТЬ)
export function FormInput({
  label,
  id,
  error,
  required,
  ...props
}: FormInputProps) {
  const errorId = error ? `${id}-error` : undefined;

  return (
    <div>
      <label htmlFor={id}>
        {label}
        {required && <span aria-label="required">*</span>}
      </label>
      <input
        id={id}
        aria-invalid={!!error}
        aria-describedby={errorId}
        {...props}
      />
      {error && <span id={errorId}>{error}</span>}
    </div>
  );
}

// Keyboard navigation utility
export function useKeyboardNavigation(
  items: any[],
  onSelect: (item: any) => void
) {
  const [selectedIndex, setSelectedIndex] = useState(0);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          setSelectedIndex(prev => (prev + 1) % items.length);
          break;
        case 'ArrowUp':
          e.preventDefault();
          setSelectedIndex(prev => (prev - 1 + items.length) % items.length);
          break;
        case 'Enter':
          e.preventDefault();
          onSelect(items[selectedIndex]);
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [items, selectedIndex, onSelect]);

  return selectedIndex;
}
```

---

### 3. Loading States & Skeletons

**Текущое состояние:** ⚠️ MINIMAL

**Рекомендация:**

```typescript
// client/src/components/skeleton-loaders.tsx (CREATE)
export function ProductCardSkeleton() {
  return (
    <Card>
      <Skeleton className="h-48 w-full" />
      <CardContent className="p-4">
        <Skeleton className="h-4 w-full mb-2" />
        <Skeleton className="h-4 w-3/4 mb-4" />
        <Skeleton className="h-8 w-full" />
      </CardContent>
    </Card>
  );
}

export function TableRowSkeleton({ columns = 5 }) {
  return (
    <TableRow>
      {Array.from({ length: columns }).map((_, i) => (
        <TableCell key={i}>
          <Skeleton className="h-6 w-full" />
        </TableCell>
      ))}
    </TableRow>
  );
}

// client/src/pages/catalog-page.tsx (УЛУЧШИТЬ)
export default function CatalogPage() {
  const { data, isLoading } = useProducts();

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {Array.from({ length: 12 }).map((_, i) => (
          <ProductCardSkeleton key={i} />
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {data?.products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

---

### 4. Form Validation UX

**Текущое состояние:** ⚠️ БАЗОВАЯ

**Рекомендация:**

```typescript
// client/src/components/form-with-validation.tsx (CREATE)
interface FormField {
  name: string;
  label: string;
  type: 'text' | 'email' | 'number' | 'textarea';
  validation: ZodSchema;
  required?: boolean;
}

export function FormWithValidation({
  fields,
  onSubmit,
}: {
  fields: FormField[];
  onSubmit: (data: Record<string, any>) => Promise<void>;
}) {
  const form = useForm({
    resolver: zodResolver(z.object(
      Object.fromEntries(
        fields.map(f => [f.name, f.validation])
      )
    )),
  });

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
      {fields.map(field => (
        <div key={field.name} className="space-y-2">
          <label htmlFor={field.name}>
            {field.label}
            {field.required && <span className="text-red-500">*</span>}
          </label>

          {field.type === 'textarea' ? (
            <textarea
              id={field.name}
              placeholder={`Введите ${field.label.toLowerCase()}`}
              {...form.register(field.name)}
              aria-invalid={!!form.formState.errors[field.name]}
              className="w-full p-2 border rounded"
            />
          ) : (
            <input
              id={field.name}
              type={field.type}
              placeholder={`Введите ${field.label.toLowerCase()}`}
              {...form.register(field.name)}
              aria-invalid={!!form.formState.errors[field.name]}
              className="w-full p-2 border rounded"
            />
          )}

          {form.formState.errors[field.name] && (
            <p className="text-red-500 text-sm">
              {form.formState.errors[field.name]?.message as string}
            </p>
          )}
        </div>
      ))}

      <Button type="submit" disabled={form.formState.isSubmitting}>
        {form.formState.isSubmitting ? 'Загрузка...' : 'Отправить'}
      </Button>
    </form>
  );
}
```

---

## ФУНКЦИОНАЛЬНЫЕ УЛУЧШЕНИЯ

### 1. Email Notifications System

**Текущое состояние:** ⚠️ Логика есть, отправка неполная

**Рекомендация:**

```typescript
// server/services/emailService.ts (CREATE)
import nodemailer from 'nodemailer';
import { logger } from '../utils/logger';

class EmailService {
  private transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: parseInt(process.env.SMTP_PORT!),
    secure: process.env.SMTP_PORT === '465',
    auth: {
      user: process.env.SMTP_USER,
      pass: process.env.SMTP_PASS,
    },
  });

  async sendOrderConfirmation(email: string, orderId: string) {
    try {
      await this.transporter.sendMail({
        from: `"ЭкоМаркет" <${process.env.SMTP_USER}>`,
        to: email,
        subject: 'Подтверждение заказа',
        html: this.getOrderConfirmationTemplate(orderId),
      });
      logger.info(`Order confirmation email sent to ${email}`);
    } catch (error) {
      logger.error(`Failed to send order confirmation: ${error}`);
      throw error;
    }
  }

  async sendOrderStatusUpdate(email: string, orderId: string, status: string) {
    try {
      await this.transporter.sendMail({
        from: `"ЭкоМаркет" <${process.env.SMTP_USER}>`,
        to: email,
        subject: `Обновление статуса заказа #${orderId}`,
        html: this.getOrderStatusTemplate(orderId, status),
      });
      logger.info(`Order status update email sent to ${email}`);
    } catch (error) {
      logger.error(`Failed to send status update: ${error}`);
    }
  }

  async sendShippingNotification(email: string, trackingNumber: string) {
    // Implementation
  }

  async sendPasswordReset(email: string, resetToken: string) {
    // Implementation
  }

  private getOrderConfirmationTemplate(orderId: string): string {
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #2d5f3f;">Ваш заказ подтвержден!</h2>
        <p>Спасибо за ваш заказ #${orderId}</p>
        <p>Статус доставки смотрите по ссылке ниже:</p>
        <a href="${process.env.SITE_URL}/orders/${orderId}">Отслеживать заказ</a>
      </div>
    `;
  }

  private getOrderStatusTemplate(orderId: string, status: string): string {
    const statusTexts: Record<string, string> = {
      pending: 'На обработке',
      shipped: 'Отправлен',
      delivered: 'Доставлен',
      cancelled: 'Отменен',
    };

    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #2d5f3f;">Обновление заказа #${orderId}</h2>
        <p>Ваш заказ теперь: <strong>${statusTexts[status]}</strong></p>
      </div>
    `;
  }
}

export const emailService = new EmailService();

// server/routes.ts - Use in order creation
app.post("/api/orders", authenticateToken, async (req, res, next) => {
  try {
    // ... create order ...
    
    // Send confirmation email
    const user = await storage.getUser(req.userId!);
    if (user) {
      await emailService.sendOrderConfirmation(user.email, order.id);
    }
    
    res.json({ orderId: order.id });
  } catch (error) {
    next(error);
  }
});
```

---

### 2. Order Management Enhancements

**Текущое состояние:** ⚠️ БАЗОВОЕ

**Рекомендация:**

```typescript
// server/services/orderService.ts (CREATE)
export class OrderService {
  async createOrder(data: CreateOrderDTO, userId: string) {
    // Validate order
    if (!data.items || data.items.length === 0) {
      throw new ValidationError('Заказ должен содержать товары');
    }

    // Check inventory
    for (const item of data.items) {
      const product = await storage.getProduct(item.productId);
      if (!product || product.stock < item.quantity) {
        throw new ValidationError(`${product?.name} нет в наличии`);
      }
    }

    // Create order
    const order = await storage.createOrder({
      userId,
      items: data.items,
      status: 'pending',
      // ...
    });

    // Update inventory
    for (const item of data.items) {
      await storage.updateProduct(item.productId, {
        stock: sql`stock - ${item.quantity}`,
      });
    }

    return order;
  }

  async cancelOrder(orderId: string) {
    const order = await storage.getOrder(orderId);
    
    if (!order) {
      throw new NotFoundError('Заказ');
    }

    if (!['pending', 'processing'].includes(order.status)) {
      throw new ValidationError('Этот заказ нельзя отменить');
    }

    // Update order
    await storage.updateOrder(orderId, { status: 'cancelled' });

    // Restore inventory
    for (const item of order.items) {
      await storage.updateProduct(item.productId, {
        stock: sql`stock + ${item.quantity}`,
      });
    }

    // Refund bonuses if used
    if (order.bonusesUsed > 0) {
      await storage.updateUser(order.userId, {
        bonusBalance: sql`bonus_balance + ${order.bonusesUsed}`,
      });
    }
  }

  async updateOrderStatus(orderId: string, status: OrderStatus) {
    const validTransitions: Record<string, OrderStatus[]> = {
      pending: ['processing', 'cancelled'],
      processing: ['shipped', 'cancelled'],
      shipped: ['delivered', 'returned'],
      delivered: ['returned'],
      cancelled: [],
      returned: [],
    };

    const order = await storage.getOrder(orderId);
    if (!order) throw new NotFoundError('Заказ');

    if (!validTransitions[order.status]?.includes(status)) {
      throw new ValidationError(
        `Невозможно изменить статус с ${order.status} на ${status}`
      );
    }

    await storage.updateOrder(orderId, { status });

    // Send notification
    const user = await storage.getUser(order.userId);
    await emailService.sendOrderStatusUpdate(user.email, orderId, status);
  }
}
```

---

### 3. Product Review System

**Текущое состояние:** ❌ ОТСУТСТВУЕТ

**Рекомендация - Database schema:**

```typescript
// shared/schema.ts - ADD
export const productReviews = pgTable('product_reviews', {
  id: varchar('id').primaryKey().default(sql`gen_random_uuid()`),
  productId: varchar('product_id').notNull().references(() => products.id),
  userId: varchar('user_id').notNull().references(() => users.id),
  orderId: varchar('order_id').notNull().references(() => orders.id),
  rating: integer('rating').notNull(),  // 1-5
  title: varchar('title').notNull(),
  content: varchar('content').notNull(),
  verified: boolean('verified').default(false),  // Verified purchase
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
},
(table) => ({
  productIdIdx: index('product_id_idx').on(table.productId),
  userIdIdx: index('user_id_idx').on(table.userId),
  verifiedIdx: index('verified_idx').on(table.verified),
  ratingIdx: index('rating_idx').on(table.rating),
}));

// server/services/reviewService.ts (CREATE)
export class ReviewService {
  async createReview(productId: string, userId: string, data: ReviewDTO) {
    // Verify user purchased product
    const purchase = await db.query.orders.findFirst({
      where: and(
        eq(orders.userId, userId),
        eq(orders.status, 'delivered'),
      ),
    });

    if (!purchase) {
      throw new ValidationError('Только покупатели могут оставлять отзывы');
    }

    // Check for existing review
    const existing = await db.query.productReviews.findFirst({
      where: and(
        eq(productReviews.productId, productId),
        eq(productReviews.userId, userId),
      ),
    });

    if (existing) {
      throw new ConflictError('Вы уже оставили отзыв на этот товар');
    }

    // Create review
    return db.insert(productReviews).values({
      productId,
      userId,
      orderId: purchase.id,
      ...data,
      verified: true,
    });
  }

  async updateReview(reviewId: string, userId: string, data: Partial<ReviewDTO>) {
    const review = await db.query.productReviews.findFirst({
      where: eq(productReviews.id, reviewId),
    });

    if (!review) throw new NotFoundError('Отзыв');
    if (review.userId !== userId) throw new AuthorizationError();

    return db.update(productReviews)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(productReviews.id, reviewId));
  }

  async getProductReviews(productId: string) {
    const reviews = await db.query.productReviews.findMany({
      where: eq(productReviews.productId, productId),
      orderBy: desc(productReviews.createdAt),
    });

    // Calculate average rating
    const avgRating = reviews.length > 0
      ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
      : 0;

    return {
      reviews,
      averageRating: Math.round(avgRating * 10) / 10,
      totalReviews: reviews.length,
    };
  }
}

// client/src/components/ProductReviewForm.tsx (CREATE)
export function ProductReviewForm({ productId }: { productId: string }) {
  const [rating, setRating] = useState(5);
  const form = useForm({
    resolver: zodResolver(z.object({
      title: z.string().min(5).max(100),
      content: z.string().min(10).max(1000),
    })),
  });

  return (
    <form onSubmit={form.handleSubmit(async (data) => {
      await reviewApi.create(productId, { rating, ...data });
    })}>
      <div>
        <label>Рейтинг</label>
        <div className="flex gap-2">
          {[1, 2, 3, 4, 5].map(num => (
            <button
              key={num}
              type="button"
              onClick={() => setRating(num)}
              className={rating >= num ? 'text-yellow-400' : 'text-gray-300'}
            >
              ★
            </button>
          ))}
        </div>
      </div>
      <FormField label="Заголовок" {...form.register('title')} />
      <FormField label="Отзыв" type="textarea" {...form.register('content')} />
      <Button type="submit">Отправить отзыв</Button>
    </form>
  );
}
```

---

## ТЕСТИРОВАНИЕ

### Testing Strategy

**Текущое состояние:** ❌ БЕЗ ТЕСТОВ

**Рекомендация:**

```typescript
// package.json - Add test scripts
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:e2e": "cypress open",
    "test:load": "artillery run load-test.yml"
  }
}

// server/services/__tests__/userService.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { UsersService } from '../users.service';
import { AppError } from '../../utils/errors';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(() => {
    service = new UsersService();
  });

  describe('registerUser', () => {
    it('should register new user', async () => {
      const user = await service.registerUser(
        'test@example.com',
        'Password123!',
        'John'
      );

      expect(user).toBeDefined();
      expect(user.email).toBe('test@example.com');
    });

    it('should throw error for existing email', async () => {
      await service.registerUser('test@example.com', 'Password123!', 'John');

      await expect(
        service.registerUser('test@example.com', 'Password456!', 'Jane')
      ).rejects.toThrow('Email уже зарегистрирован');
    });

    it('should validate password strength', async () => {
      await expect(
        service.registerUser('test@example.com', 'weak', 'John')
      ).rejects.toThrow();
    });
  });

  describe('loginUser', () => {
    it('should login with correct credentials', async () => {
      await service.registerUser('test@example.com', 'Password123!', 'John');
      const user = await service.loginUser('test@example.com', 'Password123!');

      expect(user).toBeDefined();
      expect(user.email).toBe('test@example.com');
    });

    it('should reject wrong password', async () => {
      await service.registerUser('test@example.com', 'Password123!', 'John');

      await expect(
        service.loginUser('test@example.com', 'WrongPassword!')
      ).rejects.toThrow();
    });
  });
});

// client/src/__tests__/useCart.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCart } from '../hooks/useCart';
import { QueryClientProvider } from '@tanstack/react-query';

describe('useCart hook', () => {
  it('should add item to cart', async () => {
    const { result } = renderHook(() => useCart(), {
      wrapper: QueryClientProvider,
    });

    await act(async () => {
      await result.current.addItem('product-1', 1);
    });

    expect(result.current.items).toContainEqual({
      productId: 'product-1',
      quantity: 1,
    });
  });
});

// Load testing
// artillery/load-test.yml
config:
  target: "http://localhost:5000"
  phases:
    - duration: 60
      arrivalRate: 10
scenarios:
  - name: "Homepage"
    flow:
      - get:
          url: "/"
      - get:
          url: "/api/products"
      - think: 5
      - get:
          url: "/api/products?page=2"

  - name: "Product Search"
    flow:
      - get:
          url: "/api/products?search=organic"
      - think: 3
      - get:
          url: "/api/products?search=organic&page=2"
```

---

## DEPLOYMENT & INFRASTRUCTURE

### Production Checklist

```markdown
## PRE-DEPLOYMENT SECURITY CHECKLIST

- [ ] Database
  - [ ] Backups configured (daily + weekly)
  - [ ] Connection pool limits set
  - [ ] SSL/TLS enabled
  - [ ] Read replicas configured (if needed)

- [ ] Authentication & Authorization
  - [ ] Session timeout configured
  - [ ] HTTPS enforced
  - [ ] HSTS headers set
  - [ ] 2FA available (optional for staff)
  - [ ] Audit logging enabled

- [ ] API Security
  - [ ] Rate limiting configured
  - [ ] CORS configured
  - [ ] CSRF protection enabled
  - [ ] Input validation everywhere
  - [ ] Error messages sanitized

- [ ] File Uploads
  - [ ] Virus scanning enabled
  - [ ] Size limits enforced
  - [ ] File type validation
  - [ ] Stored outside web root
  - [ ] CDN configured

- [ ] Infrastructure
  - [ ] WAF (Web Application Firewall) enabled
  - [ ] DDoS protection configured
  - [ ] Load balancing configured
  - [ ] Health checks setup
  - [ ] Monitoring & alerting configured
  - [ ] Log aggregation setup

- [ ] Data Protection
  - [ ] Encryption at rest
  - [ ] Encryption in transit
  - [ ] Data retention policies
  - [ ] GDPR/compliance audit done
  - [ ] Secrets rotation schedule

- [ ] Monitoring & Incident Response
  - [ ] Performance monitoring
  - [ ] Error tracking (Sentry)
  - [ ] Uptime monitoring
  - [ ] Incident response plan
  - [ ] On-call rotation setup

- [ ] Code Quality
  - [ ] Tests coverage > 80%
  - [ ] Code review process
  - [ ] SAST scanning (SonarQube)
  - [ ] Dependency scanning (Snyk)
  - [ ] No hardcoded secrets
```

---

## ПРИОРИТИЗАЦИЯ И ROADMAP

### PHASE 1: CRITICAL SECURITY (Week 1-2)

**🔴 MUST DO:**
1. CORS configuration
2. Rate limiting hardening
3. Input sanitization everywhere
4. Session security (Secure flag, timeouts)
5. File upload security hardening
6. Centralized error handler
7. Request logging middleware

**Impact:** ⭐⭐⭐⭐⭐  
**Effort:** ⭐⭐⭐⭐

---

### PHASE 2: ARCHITECTURE (Week 3-4)

**🟠 HIGH PRIORITY:**
1. Backend modularization (split storage.ts)
2. Frontend component refactoring
3. Unified error handling
4. Database optimization
5. Frontend state management cleanup

**Impact:** ⭐⭐⭐⭐  
**Effort:** ⭐⭐⭐⭐⭐

---

### PHASE 3: UX IMPROVEMENTS (Week 5-6)

**🟡 MEDIUM:**
1. Mobile responsiveness fixes
2. Loading skeletons
3. Accessibility improvements
4. Form validation UX
5. Error message clarity

**Impact:** ⭐⭐⭐  
**Effort:** ⭐⭐⭐

---

### PHASE 4: FEATURES (Week 7-8)

**🟢 NICE-TO-HAVE:**
1. Product review system
2. Email notifications
3. Order management enhancements
4. Analytics
5. Tests (unit/integration/E2E)

**Impact:** ⭐⭐  
**Effort:** ⭐⭐⭐⭐

---

## SUMMARY

**Total Estimated Effort:** 4-6 weeks for 1 developer

**Critical Issues Found:** 8  
**High Priority Issues:** 12  
**Medium Priority Issues:** 15  
**Low Priority Issues:** 10  

**Overall Risk Level:** 🔴 HIGH (mainly security)

Recommend starting with Phase 1 immediately, then progressive rollout of other phases.

---

*Report generated: 27 November 2025*  
*Auditor: Code Security & Architecture Analysis System*
